// Net
import "sys.base";
import "sys.list";
import "sys.func";
import "sys.proc";
import "sys.task";
import "sys.string";
import "sys.ui";
import "module.lisp";

// --------------------------------------------------------
// SERVER
var shutdown_server = func ~(out, signal, port, log) {
    call g_net_msg_shutdown_server();
    call g_printn("Shutting down msg server, port: " + port);
    if (log) { call g_write_pipe(out, "Server stopped!\n"); }
    while (true) {
        var s = call g_net_msg_get_server_status();
        if (s == 3) {
            call g_write_pipe(out, call g_net_msg_get_error() + "\n");
        }
        if (s == 0) {
            break;
        }
    }
};

var msg_receive = func ~(out, signal, port, log) {
    if (log) { call g_write_pipe(out, "Server listening...\n"); }
    while (call g_query_share(signal)) {
        var s = call g_net_msg_get_server_msg();
        if (call g_is_null(s)) {
            call g_task_sleep_signal(1, signal);
            continue;
        }
        call g_printdn("Received msg: " + s);
        var obj = call g_net_parse_json(s);
        if (call g_is_null(obj)) {
            call g_task_sleep_signal(1, signal);
            continue;
        }
        var type = call g_map_get(obj, "type");
        var addr = call g_map_get(obj, "addr");
        var content = call g_map_get(obj, "content");
        var msg = "[" + type + "] " + addr + ": " + content;
        if (log) { call g_write_pipe(out, "[" + type + "] " + addr + ": " + content + "\n"); }
        else if (type == "MSG ") { call g_write_pipe(out, content + "\n"); }
        call g_printdn("Received msg: " + msg);
    }
};

var g_net_msg_create_server = func ~(in, out, signal, port, log) {
    var r = call g_net_msg_create_server_internal(port);
    if (r) {
        if (log) { call g_write_pipe(out, "Server initializing...\n"); }
        while (true) {
            var s = call g_net_msg_get_server_status();
            if (s == 3) {
                call g_write_pipe(out, call g_net_msg_get_error() + "\n");
            }
            if (s == 0) {
                return;
            }
            if (s == 2) {
                call g_printn("Running msg server, port: " + port);
                if (log) { call g_write_pipe(out, "Server created successfully!\n"); }
                break;
            }
        }
        call msg_receive(out, signal, port, log);
        call shutdown_server(out, signal, port, log);
    } else {
        call g_write_pipe(out, "Client/Server already created!\n");
    }
};
export "g_net_msg_create_server";

// --------------------------------------------------------
// CLIENT
var shutdown_client = func ~(out, signal, addr) {
    call g_net_msg_shutdown_client();
    call g_printn("Shutting down msg client, addr: " + addr);
    call g_write_pipe(out, "Client stopped!\n");
    while (true) {
        var s = call g_net_msg_get_client_status();
        if (s == 3) {
            call g_write_pipe(out, call g_net_msg_get_error() + "\n");
        }
        if (s == 0) {
            break;
        }
    }
};

var msg_send = func ~(in, out, signal, addr) {
    call g_write_pipe(out, "Client connecting...\n");
    var i = 0;
    while (call g_query_share(signal) && i < 2) {
        var s = call g_net_msg_get_client_msg();
        if (call g_is_null(s)) {
            call g_task_sleep_signal(1, signal);
            i++;
            continue;
        }
        call g_printdn("Received msg: " + s);
        var obj = call g_net_parse_json(s);
        if (call g_is_null(obj)) {
            call g_task_sleep_signal(1, signal);
            continue;
        }
        var type = call g_map_get(obj, "type");
        var addr = call g_map_get(obj, "addr");
        var content = call g_map_get(obj, "content");
        var msg = "[" + type + "] " + addr + ": " + content;
        call g_write_pipe(out, "[" + type + "] " + addr + ": " + content + "\n");
        call g_printdn("Received msg: " + msg);
    }
    var buf = [];
    var pipe = func ["PIPE"] ~(ch, out) {
        if (ch == '\n' || ch == '\r') {
            var str = call g_string_build(buf);
            call g_printn("Sending msg: " + str);
            call g_net_msg_client_send(str);
            call g_array_clear(buf);
        } else {
            call g_array_add(buf, ch);
        }
        call g_write_pipe(out, ch);
    };
    call g_read_pipe_args(in, pipe, out);
};

var g_net_msg_create_client = func ~(in, out, signal, addr) {
    var r = call g_net_msg_create_client_internal(addr);
    if (r) {
        call g_write_pipe(out, "Client initializing...\n");
        while (true) {
            var s = call g_net_msg_get_client_status();
            if (s == 3) {
                call g_write_pipe(out, call g_net_msg_get_error() + "\n");
            }
            if (s == 0) {
                return;
            }
            if (s == 2) {
                call g_printn("Running msg client, addr: " + addr);
                call g_write_pipe(out, "Client created successfully!\n");
                break;
            }
        }
        call msg_send(in, out, signal, addr);
        call shutdown_client(out, signal, addr);
    } else {
        call g_write_pipe(out, "Client/Server already created!\n");
    }
};
export "g_net_msg_create_client";

// --------------------------------------------------------
// TASK SSHD
var sshd_shutdown_server = func ~(port) {
    call g_net_msg_shutdown_server();
    call g_printn("Shutting down msg server, port: " + port);
    while (true) {
        var s = call g_net_msg_get_server_status();
        if (s == 3) {
            call g_ui_printn(call g_net_msg_get_error());
        }
        if (s == 0) {
            break;
        }
    }
};

var task_fast_invoker = func ~(cmd, arg) {
    let cmd = call g_string_right(cmd, 1);
    call g_array_remove(arg, 0);
    if (call g_array_size(arg) == 1) {
        return call g_task_get_fast(cmd, call g_array_get(arg, 0));
    } else if (call g_array_size(arg) == 2) {
        return call g_task_get_fast_arg(cmd, call g_array_get(arg, 0), call g_array_get(arg, 1));
    } else {
        var msg = call g_array_get(arg, 0);
        call g_array_remove(arg, 0);
        return call g_task_get_fast_args(cmd, msg, arg);
    }
};

// TASK FAST INVOKER
var handle_task_command = func ~(arg) {
    var arr = call g_string_split(arg, " ");
    var cmd = call g_array_get(arr, 0);
    if (call g_string_start_with(cmd, "@")) {
        return call task_fast_invoker(cmd, arr);
    }
};

var sshd_run_lisp = func ~(code) {
    var env = call g_lisp_env();
    let code = call g_string_right(code, 1);
    var val = call g_lisp_repl(env, code);
    return val;
};

var sshd_msg_receive = func ~(port) {
    call g_ui_printn("Server listening...");
    var cnt = 0;
    call g_start_share("SSHD#EXIT", false);
    while (true) {
        if (call g_query_share("SSHD#EXIT")) {
            call g_stop_share("SSHD#EXIT");
            break;
        }
        if (!call g_is_null(call g_query_share("CMD#EXIT"))) {
            break;
        }
        var s = call g_net_msg_get_server_msg();
        if (call g_is_null(s)) {
            call g_task_sleep(1);
            continue;
        }
        call g_printdn("Received msg: " + s);
        var obj = call g_net_parse_json(s);
        if (call g_is_null(obj)) {
            call g_task_sleep(1);
            continue;
        }
        var type = call g_map_get(obj, "type");
        var origin = call g_map_get(obj, "origin");
        var addr = call g_map_get(obj, "addr");
        var content = call g_map_get(obj, "content");
        var msg = "[" + type + "] " + addr + ": " + content;
        call g_ui_printn("[" + type + "] " + addr + ": " + content);
        call g_printdn("Received msg: " + msg);
        call g_printn("*** Remote: " + content);
        if (type == "INFO" && call g_string_start_with(content, "Hello")) {
            cnt++;
            continue;
        }
        if (type == "INFO" && call g_string_start_with(content, "Bye")) {
            cnt--;
            //if (cnt == 0) { break; }
        }

        if (call g_string_start_with(content, "(")) {
            call g_net_msg_server_send_with_origin(call sshd_run_lisp(content), origin);
        } else if (call g_string_start_with(content, "@")) {
            var ret = call handle_task_command(content);
            if (call g_is_null(ret)) {
                call g_net_msg_server_send_with_origin("Error: invalid command", origin);
            } else {
                call g_net_msg_server_send_with_origin(call g_to_string(ret), origin);
            }
        } else {
            call g_net_msg_server_send_with_origin(content, origin);
        }
    }
};

var g_net_sshd = func ~(port) {
    let port = call g_string_atoi(port);
    if (port == g_minus_1) {
        return "Error: Invalid port";
    }
    var r = call g_net_msg_create_server_internal(port);
    if (r) {
        call g_ui_printn("Server initializing...");
        while (true) {
            var s = call g_net_msg_get_server_status();
            if (s == 3) {
                call g_ui_printn(call g_net_msg_get_error());
            }
            if (s == 0) {
                return "Error";
            }
            if (s == 2) {
                call g_printn("Running msg server, port: " + port);
                call g_ui_printn("Server created successfully!");
                break;
            }
        }
        call sshd_msg_receive(port);
        call sshd_shutdown_server(port);
        return "Server stopped!";
    } else {
        return "Error: Client/Server already created!";
    }
};
export "g_net_sshd";

// TASK SSHD
// --------------------------------------------------------
// TASK SSH
var ssh_shutdown_client = func ~(addr) {
    call g_net_msg_shutdown_client();
    call g_printn("Shutting down msg client, addr: " + addr);
    while (true) {
        var s = call g_net_msg_get_client_status();
        if (s == 3) {
            call g_ui_printn(call g_net_msg_get_error());
        }
        if (s == 0) {
            break;
        }
    }
};

var ssh_msg_recv = func ~(address) {
    var i = 0;
    while (i < 2) {
        // RECV
        var s = call g_net_msg_get_client_msg();
        if (call g_is_null(s)) {
            call g_task_sleep(1);
            i++;
            continue;
        }
        call g_printdn("Received msg: " + s);
        var obj = call g_net_parse_json(s);
        if (call g_is_null(obj)) {
            call g_task_sleep(1);
            i++;
            continue;
        }
        var origin = call g_map_get(obj, "origin");
        var type = call g_map_get(obj, "type");
        var addr = call g_map_get(obj, "addr");
        var content = call g_map_get(obj, "content");
        var msg = "[" + type + "] " + addr + ": " + content;
        if (type == "ECHO") {
            if (!call g_is_null(origin) && call g_net_msg_get_client_addr() == origin) {
                call g_ui_printn(content);
            }
        } else if (type == "ERR ") {
            call g_ui_printn(msg);
            return false;
        } else {
            if (!call g_is_null(origin) && call g_array_empty(address)) {
                call g_array_add(address, origin);
            }
            //call g_ui_printn("[" + type + "] " + addr + ": " + content);
        }
        call g_printdn("Received msg: " + msg);
    }
    return true;
};

var ssh_msg_send = func ~() {
    call g_ui_printn("Client connecting...");
    var address = [];
    while (true) {
        // RECV
        if (!call ssh_msg_recv(address)) {
            break;
        }

        call g_ui_print("# \uffef");
        call g_sleep(400);

        // SEND
        var cmd = call g_ui_input();
        let cmd = call g_string_trim(cmd);
        if (cmd == "exit") { break; }
        if (call g_string_length(cmd) > 0) {
            if (call g_array_empty(address)) {
                call g_net_msg_client_send(cmd);
            } else {
                call g_net_msg_client_send_with_origin(cmd, call g_array_get(address, 0));
            }
        }
    }
};

var g_net_ssh = func ~(addr) {
    var r = call g_net_msg_create_client_internal(addr);
    if (r) {
        call g_ui_printn("Client initializing...");
        while (true) {
            var s = call g_net_msg_get_client_status();
            if (s == 3) {
                call g_ui_printn(call g_net_msg_get_error());
            }
            if (s == 0) {
                return "Error";
            }
            if (s == 2) {
                call g_printn("Running msg client, addr: " + addr);
                call g_ui_printn("Client created successfully!");
                break;
            }
        }
        call ssh_msg_send();
        call ssh_shutdown_client(addr);
        return "Client stopped!";
    } else {
        return "Error: Client/Server already created!";
    }
};
export "g_net_ssh";

// TASK SSH
// --------------------------------------------------------