import "sys.base";
import "sys.list";
import "sys.proc";
import "sys.task";
import "sys.string";
import "sys.class";
import "sys.math";
import "sys.ui";
import "module.lisp";

call g_set_process_desc("test routinue");
var pid = call g_get_pid();
var share = call g_wait_share("PID#" + pid);
call g_stop_share("PID#" + pid);
var args = call g_map_get(share, "args");

var in = call g_create_pipe("PIPEIN#" + pid);
var out = call g_create_pipe("PIPEOUT#" + pid);

var put = func ["PIPE"] ~(ch) {
    call g_write_pipe(out, ch);
};
var puts = func ["PIPE"] ~(str) {
    foreach (var c : call g_range_string(str)) {
        call g_write_pipe(out, c);
    }
};
var signal = "PIDSIG#" + pid;
call g_start_share(signal, true);

/* 创建场景 */
var create_stage = func ~(f) -> call f();

/* 重复操作 */
var real_repeat = func ~(_operation, _arg, _start, _end) {
    var repeat = func ~(operation, arg, start, end) {
        var index = start;
        var repeat0 = func ~() {
            if (index >= end) { return; }
            call operation(arg, index);
            return call repeat(operation, arg, ++index, end);
        };
        return repeat0;
    };
    var repear_f = func ~() -> call repeat(_operation, _arg, _start, _end);
    call(func ~(f) {
        while (!(call g_is_null(f)) && (call g_get_type_ordinal(f) == 8)) {
            let f = call f();
        }
    })(repear_f);
};
    
/* 打字效果 */
var word_typewrite0 = func ~(str, span) {
    var print = func ~(a, n) {
        call put(call g_string_char(a, n));
        call g_task_sleep_ms_signal(span, signal);
    };
    call real_repeat(print, str, 0, call g_string_length(str));
};

/* 打字效果 */
var word_typewrite = func ~(str, span) {
    foreach (var c : call g_range_string(str)) {
        call put(c);
        call g_task_sleep_ms_signal(span, signal);
    }
    call put(g_endl);
};

/* 清屏 */
var stage_clear = func ~() {
    call word_typewrite("Are you ready?", 200);
    call word_typewrite("  3!  2!  1!\n", 300);
    call word_typewrite("  Let's go!!!   \n", 300);
    call put('\f');
};

/* 场景一 */
var stage_1 = func ~() {
    call puts(call g_string_rep(" ", 31));
    call word_typewrite("- Stage 1 -\n", 400);
    call word_typewrite("* Hello world! 你好！\n", 80);
    call word_typewrite("* This is a test program. 这是一个测试程序。\n", 80);
    call word_typewrite("* Made by bajdcc. 由bajdcc编写。\n", 80);
    call word_typewrite("* 项目网址在 https://github.com/bajdcc/jMiniLang 上。\n", 100);
    call word_typewrite("* 这是我做的一个脚本操作系统。\n", 100);
    call word_typewrite("* 支持闭包、进程、管道、互斥等特性。\n", 100);
    call word_typewrite("* 不过由于设计不足以及Java的使用，脚本运行还是太慢。\n", 100);
    call word_typewrite("* 最让我兴奋的是语法分析的实现、虚拟机的构建、同步/异步语义的实现。\n", 100);
    call word_typewrite("* 进程、管道、互斥是这个操作系统的基础。\n", 100);
    call word_typewrite("\n\n\n\n", 400);
    call puts(call g_string_rep(" ", 31));
    call word_typewrite("- @bajdcc -\n", 400);
};

// ------------------------------------

/* 哲学家就餐问题 */
var stage_philo = func ~() {
    call word_typewrite("演示哲学家就餐问题！    \n", 100);
    call g_create_mutex("philo_print");
    foreach (var i : call g_range(1, 5)) {
        call g_create_semaphore("fork_" + i, 1); // 每个叉最多能使用一次
    }
    var handles = [];
    var philo = func ~(args) {
        var eat = call g_map_get(args, "eating");
        var o = call g_map_get(args, "out");
        var id = call g_map_get(args, "id");
        var left_id = call g_map_get(args, "left_id");
        var right_id = call g_map_get(args, "right_id");
        var left = call g_use_semaphore("fork_" + left_id);
        var right = call g_use_semaphore("fork_" + right_id);
        call eat(o, "Philosophy#" + id + " ready");
        foreach (var j : call g_range(1, 10)) {
            call g_lock_semaphore(left); // P左
            call eat(o, "Philosophy#" + id + " is using fork#" + left_id);
            call g_lock_semaphore(right); // P右
            call eat(o, "Philosophy#" + id + " is using fork#" + right_id);
            call eat(o, "Philosophy#" + id + " is eating. Process: " + j + "0%");
            call g_unlock_semaphore(left); // V左
            call g_unlock_semaphore(right); // V右
        }
        call eat(o, "Philosophy#" + id + " OK");
    };
    var eating = func ~(out, str) {
        var pm = call g_use_mutex("philo_print");
        call g_lock_mutex(pm);
        foreach (var c : call g_range_string(str)) {
            call g_write_pipe(out, c);
        }
        call g_write_pipe(out, '\n');
        call g_task_sleep_ms_signal(100, signal);
        call g_unlock_mutex(pm);
    };
    foreach (var j : call g_range(1, 5)) {
        var args = {};
        call g_map_put(args, "eating", eating);
        call g_map_put(args, "out", out);
        call g_map_put(args, "id", j);
        call g_map_put(args, "left_id", (j == 1) ? 5 : (j - 1));
        call g_map_put(args, "right_id", (j == 5) ? 1 : (j + 1));
        var h = call g_create_user_process_args(philo, args);
        call g_array_add(handles, h);
        call g_task_sleep(1);
    }
    call g_join_process_array(handles);
    foreach (var k : call g_range(1, 5)) {
        call g_destroy_semaphore(call g_use_semaphore("fork_" + k));
    }
    call g_destroy_mutex(call g_use_mutex("philo_print"));
};

/* 哲学家就餐问题 - 管程解决 */
var stage_philo2 = func ~() {
    call word_typewrite("【管程】演示哲学家就餐问题！    \n", 100);
    call g_create_mutex("philo_print");
    call g_create_mutex("philo_monitor");
    var states = [];
    call g_array_add(states, g_null);
    foreach (var i : call g_range(1, 5)) {
        call g_create_semaphore("philo_" + i, 1); // 记录每个哲学家的状态（管程）
        call g_array_add(states, "thinking"); // 开始时哲学家都在思考
    }
    var handles = [];
    var philo2 = func ~(args) {
        var eat = call g_map_get(args, "eating");
        var states = call g_map_get(args, "states");
        var o = call g_map_get(args, "out");
        var id = call g_map_get(args, "id");
        var left_id = call g_map_get(args, "left_id");
        var right_id = call g_map_get(args, "right_id");
        var monitor = call g_use_mutex("philo_monitor");
        call eat(o, "Philosophy#" + id + " ready");
        var enter = func ~() { // 进入临界区
            var monitor = call g_use_mutex("philo_monitor");
            call g_lock_mutex(monitor); // mutex自带等待队列
            call g_printdn("Philosophy#" + id + " entered critical section");
        };
        var leave = func ~() { // 离开临界区
            call g_printdn("Philosophy#" + id + " leaved critical section");
            var monitor = call g_use_mutex("philo_monitor");
            call g_unlock_mutex(monitor);
        };
        var wait = func ~(_id) { // 等待信号
            var sem = call g_use_semaphore("philo_" + _id);
            call g_printdn("Philosophy#" + _id + " waiting");
            call g_lock_mutex(sem); // semaphore自带等待队列
        };
        var signal = func ~(_id) { // 发出信号
            var sem = call g_use_semaphore("philo_" + _id);
            call g_unlock_mutex(sem);
            call g_printdn("Philosophy#" + _id + " received signal");
        };
        var test = func ~(_id) { // 测试哲学家是否具备进餐条件
            var _left_id = (_id == 1) ? 5 : (_id - 1);
            var _right_id = (_id == 5) ? 1 : (_id + 1);
            if ((call g_array_get(states, _left_id) != "eating") && // 如果左右都不在进餐
                (call g_array_get(states, _right_id) != "eating") &&
                (call g_array_get(states, _id) == "hungry")) { // 且自己为饥饿状态
                call signal(_id); // 发出就餐信号
            } else {
                call g_printdn("Test failed. #" + _left_id + ": " + call g_array_get(states, _left_id) +
                    ", #" + _right_id + ": " + call g_array_get(states, _right_id) + ", #" +
                    _id + ": " +　call g_array_get(states, _id));
            }
        };
        var pickup = func ~() { // 拿起叉子
            call enter();
            call g_array_set(states, id, "hungry"); // 设置状态是饥饿
            call test(id);
            call leave();
            if (call g_array_get(states, id) != "eating") { // 如果尝试失败
                call wait(id); // 等待
                call g_array_set(states, id, "eating"); // 设置为进餐状态
            }
        };
        var putdown = func ~() { // 放下叉子
            call enter();
            call g_array_set(states, id, "thinking"); // 设置状态是思考
            call test(left_id); // 测试左边的哲学家可否就餐
            call test(right_id); // 测试右边的哲学家可否就餐
            call leave();
        };
        foreach (var j : call g_range(1, 10)) {
            call eat(o, "Philosophy#" + id + " is thinking");
            call pickup();
            call eat(o, "Philosophy#" + id + " is eating. Process: " + j + "0%");
            call putdown();
        }
        call eat(o, "Philosophy#" + id + " OK");
    };
    var eating = func ~(out, str) {
        var pm = call g_use_mutex("philo_print");
        call g_lock_mutex(pm);
        foreach (var c : call g_range_string(str)) {
            call g_write_pipe(out, c);
        }
        call g_write_pipe(out, '\n');
        call g_task_sleep_ms_signal(100, signal);
        call g_unlock_mutex(pm);
    };
    foreach (var j : call g_range(1, 5)) {
        var args = {};
        call g_map_put(args, "eating", eating);
        call g_map_put(args, "states", states);
        call g_map_put(args, "out", out);
        call g_map_put(args, "id", j);
        call g_map_put(args, "left_id", (j == 1) ? 5 : (j - 1));
        call g_map_put(args, "right_id", (j == 5) ? 1 : (j + 1));
        var h = call g_create_user_process_args(philo2, args);
        call g_array_add(handles, h);
    }
    call g_join_process_array(handles);
    foreach (var k : call g_range(1, 5)) {
        call g_destroy_semaphore(call g_use_semaphore("fork_" + k));
    }
    call g_destroy_mutex(call g_use_mutex("philo_print"));
};

// -------------------------------------
// lisp
/* LISP 测试示例 */
var stage_lisp = func ~() {
    call word_typewrite("\n    TEST LISP!!!       @jMiniLisp \n", 100);
    var env = call g_lisp_env();
    var eval = func~(exp) {
        call puts("\n");
        //call puts("jMiniLisp> ");
        call word_typewrite(exp + "\n", 30);
        var val = call g_lisp_repl(env, exp);
        if (val != "null") {
            call puts("= ");
            call word_typewrite(val + "\n", 30);
        }
    };
    var comment = func~(str) -> call word_typewrite("\n    " + str + "\n\n", 40);
    var out_call = func~(strs) -> call word_typewrite(call g_array_get(strs, 0) + "\n", 35);
    call g_map_put(env, "out", out_call);
    var builtin = func~(str) {
        call puts("\n");
        //call puts("jMiniLisp> ");
        call word_typewrite(str + "\n", 25);
    };
    // eval code
    // ##########################
    call comment("1. Lambda");
    call eval("(define circle-area
    (lambda (r)
        (* PI
            (* r r))))");
    call eval("(circle-area 10)");
    call eval("(define fact
    (lambda (n)
        (if (<= n 1)
            1
            (* n (fact (- n 1))))))");
    call eval("(fact 10)");
    // ##########################
    call comment("2. List");
    call eval("(list 1 2 3 4 5)");
    call eval("(range 1 10)");
    call eval("(define L (list 1 2 3 4 5))");
    call eval("(car L)");
    call eval("(cdr L)");
    // ##########################
    call comment("3. Count");
    call builtin("(define count
    (lambda (item L)
        (if L
            (+ 0
                (== item (car L))
                (count item (cdr L)))
            0)))");
    call eval("(count 0 (list 0 1 2 3 0 0))");
    call eval("(count 'the
    '(the more the merrier the bigger the better))");
    // ##########################
    call comment("4. Type");
    call eval("(null? (list))");
    call eval("(number? 5.0)");
    call eval("(number? (list))");
    call eval("(type 'hello)");
    call eval("(list? (list))");
    call eval("(car '(a b c))");
    call eval("(type (car '(a b c)))");
    call eval("(cdr (cons 'a '(b c)))");
    // ##########################
    call comment("5. Function");
    call eval("(define repeat
    (lambda (f)
        (lambda (x)
            (f (f x)))))");
    call eval("(define twice
    (lambda (x)
        (* 2 x)))");
    call eval("((repeat twice) 10)");
    call eval("(define sum
    (lambda (n)
        (if (< n 2)
            1
            (+ n (sum (- n 1))))))");
    call eval("(sum 10)");
    call eval("(min 50 60)");
    call eval("(range 0 10)");
    call eval("(define fib
    (lambda (n)
        (if (<= n 2)
            1
            (+ (fib (- n 1)) (fib (- n 2))))))");
    call eval("(fib 10)");
    call eval("(map fib (list 3 2 3 4 5))");
    call eval("(map fib (range 1 10))");
    call eval("(map
    (lambda (n)
        ((repeat twice) n))
    (range 1 10))");
    call builtin("(define apply
    (lambda (item L)
        (eval (cons item L))))");
    call eval("(apply +
    (list \"hello\" #s \"world\" #s \"bajdcc!\"))");
    call eval("(apply + (range 1 10))");
    call eval("(append '(a b) '(c d))");
    call eval("(apply 'append '('(a b) '(c d)))");
    call eval("(apply max (range 1 10))");
    call builtin("(define Y
    (lambda (F)
        ((lambda (self)
            (F (lambda (x)((self self) x))))
        (lambda (self)
            (F (lambda (x)((self self) x))))))))))");
    call eval("(define fib_Y
    (lambda (f)
        (lambda (n)
            (if (<= n 2)
                1
                (+ (f (- n 1)) (f (- n 2)))))))");
    call eval("(apply + (map (Y fib_Y) (range 1 10)))");
    // ##########################
    call comment("6. Condition");
    call eval("(cond
    ((== 1 2) 3 7)
    ((== 4 4) 6))");
    call eval("(cond
    ((== 1 2) 3)
    ((== 4 4) 6))");
    call eval("(define N 8)");
    call eval("(case N
    (1 2)
    (8 9))");
    call eval("(case N
    (3 2)
    (2 9)
    ('(4 8) 5))");
    call eval("(when (> N 5) 6)");
    call eval("(when (> N 50) 6)");
    call eval("(while (> N 1)
    (set! N (-- N)))");
    call eval("(val N)");
    call eval("(while (<= N 10)
    (begin
        (out (+ \"Hello_world!_\" (str N)))
        (set! N (++ N))))");
    // ##########################
    call comment("The end.                @bajdcc");
};

// ---------------------------------------------------------
// 打印古诗

var cols = call g_ui_cols();
var rows = call g_ui_rows();

/* 打字效果（空格不算） */
var word_typewrite_fast = func ~(span, str) {
    var l = call g_ui_text_length(str);
    var space = (cols - l) / 2;
    call puts(call g_string_rep(" ", space));
    foreach (var c : call g_range_string(str)) {
        call put(c);
        call g_task_sleep_ms_signal(span, signal);
    }
    call put(g_endl);
};

/* 换页特效 */
var stage_trans = func ~() {
    call word_typewrite_fast(900, "...");
    call put('\f');
};

/* 打印古诗 */
var stage_font = func ~() {
    call put('\f');
    var text = "

- 登幽州台歌 -

陈子昂



  前不见古人，

  后不见来者。

  念天地之悠悠，

  独怆然而涕下！

.

- 春望 -

杜甫



  国破山河在，城春草木深。

  感时花溅泪，恨别鸟惊心。

  烽火连三月，家书抵万金。

  白头搔更短，浑欲不胜簪。

.

- 如梦令·昨夜雨疏风骤 -

李清照



  昨夜雨疏风骤，

  浓睡不消残酒。

  试问卷帘人，

  却道海棠依旧，

  知否，知否？

  应是绿肥红瘦。

.

- 龟虽寿 -

曹操



  神龟虽寿，犹有竟时。

  螣蛇乘雾，终为土灰。

  老骥伏枥，志在千里。

  烈士暮年，壮心不已。

  盈缩之期，不但在天。

  养怡之福，可得永年。

  幸甚至哉！歌以咏志。

";
    var t = call g_string_split(text, '\n');
    foreach (var s : call g_range_array(t)) {
        if (call g_string_start_with(s, ".")) {
            call stage_trans();
        } else {
            call word_typewrite_fast(80, s);
        }
    }
};

// ---------------------------------------------
// FORK

var stage_fork = func ~() {
    var fork_proc = func ~() {
        call g_set_process_desc("fork job");
        var fork_entry = func ~(arg) {
            call g_set_process_desc("fork #" + arg);
            call g_sleep(50);
            var o = call g_create_pipe("FORK#COUNT");
            call g_write_pipe(o, '*');
        };
        for (var i = 0; i < 20000; i++) {
            call g_create_user_process_args(fork_entry, i);
        }
    };
    call g_create_user_process(fork_proc);
    var __in = call g_create_pipe("FORK#COUNT");
    var count = 0;
    call g_read_pipe_args(__in, lambda(ch, out) {
        call puts("" + count + "\r");
        count++;
        if (count >= 20000) {
            call puts("Tested 20000 process.\n");
            call g_destroy_pipe(call g_create_pipe("FORK#COUNT"));
        }
    }, out);
};

// ---------------------------------------------
// CLASS

var stage_class = func ~() {
    var print = func ~(str) -> call word_typewrite(str, 10);
    var ctx = call g_create_context();
    call g_register_class(ctx, "shape", lambda(this) {
        call g_create_property(this, "type", "shape");
        call g_create_method(this, "get_area", lambda(this)->0);
    }, g_null);
    call g_register_class(ctx, "square", lambda(this) {
        call g_create_property(this, "type", "square");
        call g_create_property(this, "a", 0);
        call g_create_property(this, "b", 0);
        call g_create_method(this, "get_area", lambda(this) {
            return call g_get_property(this, "a") * call g_get_property(this, "b");
        });
        call g_create_method(this, "to_string", lambda(this) {
            return "" + call g_get_property(this, "type")
            + " a=" + call g_get_property(this, "a")
            + " b=" + call g_get_property(this, "b")
            + " area="
            + call g_invoke_method(this, "get_area");
        });
    }, "shape");
    call g_register_class(ctx, "circle", lambda(this){
        call g_create_property(this, "type", "circle");
        call g_create_property(this, "r", 0);
        call g_create_method(this, "get_area", lambda(this){
            var r = call g_get_property(this, "r");
            return 3.14 * r * r;
        });
        call g_create_method(this, "to_string", lambda(this){
            return "" + call g_get_property(this, "type")
            + " r=" + call g_get_property(this, "r")
            + " area="
            + call g_invoke_method(this, "get_area");
        });
    }, "shape");

    var square = call g_create_class(ctx, "square");
    call g_set_property(square, "a", 5);
    call g_set_property(square, "b", 6);
    call print("" + call g_get_property(square, "type")
        + " a=" + call g_get_property(square, "a")
        + " b=" + call g_get_property(square, "b")
        + " area=" + call g_invoke_method(square, "get_area"));
    var circle = call g_create_class(ctx, "circle");
    call g_set_property(circle, "r", 10);
    call g_set_property(circle, "s", square);
    call print("" + call g_get_property(circle, "type")
        + " r=" + call g_get_property(circle, "r")
        + " area=" + call g_invoke_method(circle, "get_area"));
    call print(call g_invoke_method(square, "to_string"));
    call print(call g_invoke_method(circle, "to_string"));

    call print("" + square."type"
        + " a=" + square."a"
        + " b=" + square."b"
        + " area=" + call g_invoke_method(square, "get_area"));
    call print("" + circle."type"
        + " r=" + circle."r"
        + " sa=" + circle."s"."a"
        + " sb=" + circle."s"."b"
        + " area=" + call g_invoke_method(circle, "get_area"));
};


var name = call g_array_get(args, 0);
if (call g_is_null(name)) {
    call create_stage(stage_clear);
    call create_stage(stage_1);
} else if (name == "philo") {
    call create_stage(stage_philo);
} else if (name == "philo2") {
    call create_stage(stage_philo2);
} else if (name == "lisp") {
    call create_stage(stage_lisp);
} else if (name == "font") {
    call stage_font();
} else if (name == "fork") {
    call stage_fork();
} else if (name == "class") {
    call stage_class();
} else {
    call g_read_pipe_args(in, lambda(ch, out) -> call g_write_pipe(out, ch), out);
}

call g_stop_share(signal);
call g_destroy_pipe(out);
call g_destroy_pipe(in);