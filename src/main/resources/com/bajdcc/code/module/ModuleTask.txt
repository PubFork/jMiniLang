import "sys.base";
import "sys.list";
import "sys.proc";

var g_task_init = func ~() {
    var task_table = [];
    g_start_share("TASK#TABLE", task_table);
    foreach (var i : g_range(0, 16 - 1)) {
        g_array_add(task_table, g_null);
    }
    var waiting_list = [];
    g_start_share("TASK#LIST", waiting_list);
};
export "g_task_init";

var g_task_add_proc = func ~(no, data) {
    var task_table = g_query_share("TASK#TABLE");
    g_array_set(task_table, no, data);
    g_printdn("Task #" + no + " created");
};
export "g_task_add_proc";

/* 下面区别三种对象：客户端、代理端、服务端
 *   1. 客户端（调用者）
 *      调用方法：客户端进程调用g_task_get/g_task_get_fast/g_task_get_fast_arg，获取数据
 *   2. 代理端（充当中介）
 *      已实现的task_handler，它的目的是连接客户端和服务端
 *   3. 服务端（服务者）
 *      这方面要自己实现
 *
 * 调用顺序：
 *   1. 客户端调用task_get_fast等方法
 *   2. task_get_fast安排好请求数据，触发int#1服务中断
 *   3. 中断会调用task_handler代理方法
 *   4.
 */

/* 客户端向代理端发送消息 */
var g_task_get = func ~(tid, msg) {
    var waiting_list = g_query_share("TASK#LIST");
    if (g_is_null(waiting_list)) {
        g_map_put(msg, "error", "1");
        g_map_put(msg, "val", "Service shutdown.");
        return;
    }
    var pid = g_get_pid();
    var m = {};
    g_map_put(m, "pid", pid);
    g_map_put(m, "tid", tid);
    g_map_put(m, "msg", msg);
    g_start_share("MSG#" + pid, m);       // 准备请求数据
    g_lock_share("TASK#LIST");            // 锁定等待队列
    g_array_add(waiting_list, pid);       // 将当前进程添加至代理端的等待队列中
    g_unlock_share("TASK#LIST");          // 解锁队列
    var handle = g_create_pipe("int#1");  // 报告服务中断例程
    g_write_pipe(handle, '@');            // 发送消息事件给中断例程，使之调用task_handler
    var h = g_wait_pipe("IPC#" + pid);    // 等待代理端处理完毕，此时代理端会发服务端发送请求
    var f = func ~(ch) {
        if (ch == 'E') { g_destroy_pipe(h); }
    };
    g_read_pipe(h, f);                    // 等待代理端处理完毕
    g_stop_share("MSG#" + pid);
};
export "g_task_get";

var g_task_get_fast = func ~(tid, id) {
    var arg = [tid, id];
    var msg = {"id": id, "arg": arg};
    g_task_get(tid, msg);
    var error = msg["error"];
    var val = msg["val"];
    if (error == 1) {
        return g_null;
    } else {
        return val;
    }
};
export "g_task_get_fast";
var g_task_get_fast_arg = func ~(tid, id, a) {
    var arg = [tid, id, a];
    var msg = {"id": id, "arg": arg};
    g_task_get(tid, msg);
    var error = msg["error"];
    var val = msg["val"];
    if (error == 1) {
        return g_null;
    } else {
        return val;
    }
};
export "g_task_get_fast_arg";
var g_task_get_fast_args = func ~(tid, id, a) {
    var arg = [];
    g_array_add(arg, tid);
    g_array_add(arg, id);
    g_array_append(arg, a);

    var msg = {};
    g_map_put(msg, "id", id);
    g_map_put(msg, "arg", arg);
    g_task_get(tid, msg);
    var error = msg["error"];
    var val = msg["val"];
    if (error == 1) {
        return g_null;
    } else {
        return val;
    }
};
export "g_task_get_fast_args";

/* 代理端处理客户端的消息 */
var task_handler = func ~(ch) {
    var waiting_list = g_query_share("TASK#LIST");
    if (g_is_null(waiting_list)) {
        return;
    }
    var task_table = g_query_share("TASK#TABLE");
    g_lock_share("TASK#LIST");                     // 锁定等待队列
    var pid = waiting_list[0];        // 取最早等待的进程
    g_array_remove(waiting_list, 0);               // 移除它
    g_unlock_share("TASK#LIST");                   // 解锁队列
    var m = g_query_share("MSG#" + pid);           // 读取客户端的数据
    var _tid = m["tid"];
    var tid = g_task_get_id_by_name(_tid);
    var msg = m["msg"];
    if (g_is_null(tid)) {
        g_map_put(msg, "error", 1);
        g_map_put(msg, "val", "invalid task name");
    } else {
        g_map_put(msg, "error", 0);
        g_start_share("TASKDATA#" + tid, msg);
        g_start_share("TASKCALLER#" + tid, pid);
        var h = g_create_pipe("TASKSEND#" + tid);  // 连接服务端
        g_write_pipe(h, ch);                       // 唤醒服务端，这时服务端在处理请求
        var h1 = g_create_pipe("TASKRECV#" + tid); // 连接服务端
        var f1 = func ~(ch) {
             if (ch == 'E') { g_destroy_pipe(h1); }
        };
        g_printdn("Waiting task: PID#" + pid + " -> TASK#" + _tid);
        g_read_pipe(h1, f1);                       // 防止多个代理端同时请求服务端，用管道做阻塞
        g_printdn("Waiting task: PID#" + pid + " -> TASK#" + _tid + " ok");
        g_stop_share("TASKDATA#" + tid);
        g_stop_share("TASKCALLER#" + tid);
    }
    var handle = g_create_pipe("IPC#" + pid);      // 处理完毕
    g_write_pipe(handle, 'E');                     // 唤醒客户端
};

var g_task_handler = func ~(ch) -> task_handler(ch);
export "g_task_handler";
var g_task_get_id_by_name = func ~(name) {
    var task_name_table = g_query_share("TASK#NAMELIST");
    foreach (var i : g_range(0, 16 - 1)) {
        var t = task_name_table[i];
        if (!g_is_null(t) && t == name) {
            return i;
        }
    }
    return g_null;
};
export "g_task_get_id_by_name";
var g_task_sleep = func ~(second) {
    if (second < 1) { return; }
    var begin = g_task_get_timestamp();
    var end = begin + second * 1000;
    while (begin < end) {
        begin := g_task_get_timestamp();
        g_sleep(500);
    }
};
export "g_task_sleep";
var g_task_sleep_signal = func ~(second, signal) {
    if (second < 1) { return; }
    var begin = g_task_get_timestamp();
    var end = begin + second * 1000;
    while (begin < end) {
        begin := g_task_get_timestamp();
        var s = g_query_share(signal);
        if (g_is_null(s) || !s) {
            g_printdn("Sleep_s interrupt: #" + g_get_pid() + " -> " + signal);
            break;
        }
        g_sleep(500);
    }
};
export "g_task_sleep_signal";
var g_task_sleep_ms = func ~(ms) {
    if (ms < 1) { return; }
    var begin = g_task_get_timestamp();
    var end = begin + ms;
    while (begin < end) {
        begin := g_task_get_timestamp();
        g_sleep(20);
    }
};
export "g_task_sleep_ms";
var g_task_sleep_ms_signal = func ~(ms, signal) {
    if (ms < 1) { return; }
    var begin = g_task_get_timestamp();
    var end = begin + ms;
    while (begin < end) {
        begin := g_task_get_timestamp();
        var s = g_query_share(signal);
        if (g_is_null(s) || !s) {
            g_printdn("Sleep_ms interrupt: #" + g_get_pid() + " -> " + signal);
            break;
        }
        g_sleep(20);
    }
};
export "g_task_sleep_ms_signal";